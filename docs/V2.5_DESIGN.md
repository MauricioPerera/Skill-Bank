# ğŸ” v2.5 Design: Core Security & Performance

**Skill Bank Enhancement Proposal**  
**Version:** 2.5.0  
**Status:** Design Phase  
**Target Release:** Q1 2026

---

## Executive Summary

v2.5 enhances the v2.0 Credentials Vault with four critical improvements:

1. **Argon2id Support** - Modern KDF for better GPU/ASIC resistance
2. **Credential Caching** - 10x performance improvement with security controls
3. **Audit Chain Verification** - Forensic-grade tamper-proof logs
4. **Just-in-Time Access** - Temporal credential elevation with risk scoring

**Goals:**
- âœ… 10x faster credential retrieval (6ms â†’ 0.6ms cached)
- âœ… Forensic-grade audit trail (blockchain-like verification)
- âœ… Future-proof cryptography (Argon2id)
- âœ… Zero-standing-privileges model (JIT access)
- âœ… 100% backward compatible with v2.0

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Feature 1: Argon2id Support](#feature-1-argon2id-support)
3. [Feature 2: Credential Caching](#feature-2-credential-caching)
4. [Feature 3: Audit Chain Verification](#feature-3-audit-chain-verification)
5. [Feature 4: Just-in-Time Access](#feature-4-just-in-time-access)
6. [Database Schema Changes](#database-schema-changes)
7. [API Changes](#api-changes)
8. [Migration Path](#migration-path)
9. [Performance Benchmarks](#performance-benchmarks)
10. [Security Analysis](#security-analysis)
11. [Testing Strategy](#testing-strategy)

---

## Architecture Overview

### Current Stack (v2.0)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Application (Skills/Tools)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Access Control (Policy-Based)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Encryption (AES-256-GCM + PBKDF2) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Storage (SQLite)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Enhanced Stack (v2.5)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Application (Skills/Tools)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   JIT Access Manager â­ NEW          â”‚
â”‚   â€¢ Temporal elevation              â”‚
â”‚   â€¢ Risk scoring                    â”‚
â”‚   â€¢ MFA integration                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Credential Cache â­ NEW            â”‚
â”‚   â€¢ In-memory LRU                   â”‚
â”‚   â€¢ Sliding TTL                     â”‚
â”‚   â€¢ Auto-invalidation               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Access Control (Policy-Based)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Encryption (Multi-KDF) â­ ENHANCED â”‚
â”‚   â€¢ AES-256-GCM                     â”‚
â”‚   â€¢ PBKDF2 (legacy)                 â”‚
â”‚   â€¢ Argon2id (default) â­ NEW        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Storage (SQLite)                  â”‚
â”‚   â€¢ Chained audit logs â­ ENHANCED   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Feature 1: Argon2id Support

### Problem Statement

PBKDF2 is secure but has limitations:
- **Not memory-hard** - Vulnerable to GPU/ASIC attacks
- **Parallelizable** - Attackers can use multiple cores effectively
- **Aging algorithm** - Recommended by NIST in 2000, superseded by Argon2 (2015)

### Solution: Argon2id

Argon2id combines:
- **Memory-hardness** (like Argon2i) - Protects against time-memory tradeoff attacks
- **Data-dependent** (like Argon2d) - Protects against GPU cracking
- **Winner of Password Hashing Competition (2015)**

### Technical Design

#### New KDF Interface

```typescript
/**
 * Key Derivation Function types
 */
export type KDFType = 'pbkdf2' | 'argon2id';

/**
 * KDF parameters for different algorithms
 */
export interface KDFParameters {
  // PBKDF2 parameters
  iterations?: number;
  hash?: 'sha256' | 'sha512';
  
  // Argon2 parameters
  memoryCost?: number;     // Memory in KiB (default: 65536 = 64MB)
  timeCost?: number;       // Iterations (default: 3)
  parallelism?: number;    // Threads (default: 4)
}

/**
 * KDF configuration
 */
export interface KDFConfig {
  type: KDFType;
  parameters: KDFParameters;
  version: string;
}

/**
 * Default configurations
 */
export const DEFAULT_KDF_CONFIGS: Record<KDFType, KDFConfig> = {
  pbkdf2: {
    type: 'pbkdf2',
    parameters: {
      iterations: 100000,
      hash: 'sha256'
    },
    version: '1.0'
  },
  argon2id: {
    type: 'argon2id',
    parameters: {
      memoryCost: 65536,    // 64 MB
      timeCost: 3,          // 3 iterations
      parallelism: 4        // 4 threads
    },
    version: '1.3'
  }
};
```

#### Encryption Metadata Update

```typescript
export interface EncryptedCredential {
  encryptedValue: string;
  salt: string;
  iv: string;
  authTag: string;
  
  // NEW: KDF metadata
  kdfType: KDFType;
  kdfParameters: KDFParameters;
  kdfVersion: string;
}
```

#### Key Derivation Implementation

```typescript
import argon2 from 'argon2';

/**
 * Derive key using specified KDF
 */
export async function deriveKey(
  masterKey: Buffer,
  salt: Buffer,
  config: KDFConfig
): Promise<Buffer> {
  switch (config.type) {
    case 'pbkdf2':
      return crypto.pbkdf2Sync(
        masterKey,
        salt,
        config.parameters.iterations || 100000,
        32,
        config.parameters.hash || 'sha256'
      );
    
    case 'argon2id':
      const hash = await argon2.hash(masterKey, {
        type: argon2.argon2id,
        salt,
        memoryCost: config.parameters.memoryCost || 65536,
        timeCost: config.parameters.timeCost || 3,
        parallelism: config.parameters.parallelism || 4,
        hashLength: 32,
        raw: true
      });
      return Buffer.from(hash);
    
    default:
      throw new Error(`Unsupported KDF type: ${config.type}`);
  }
}
```

### Migration Strategy

#### 1. Gradual Rollout

```typescript
// Environment variable controls default KDF
// DEFAULT_KDF_TYPE=argon2id (v2.5+)
// DEFAULT_KDF_TYPE=pbkdf2 (legacy, v2.0 compatible)

export function getDefaultKDF(): KDFType {
  const env = process.env.DEFAULT_KDF_TYPE;
  if (env === 'argon2id' || env === 'pbkdf2') {
    return env;
  }
  // Default to argon2id in v2.5+
  return 'argon2id';
}
```

#### 2. Backward Compatibility

```typescript
export function decryptCredential(
  encrypted: EncryptedCredential,
  masterKey: Buffer
): any {
  // Detect KDF type from metadata
  const kdfType = encrypted.kdfType || 'pbkdf2'; // Default to PBKDF2 for v2.0 data
  
  const config: KDFConfig = {
    type: kdfType,
    parameters: encrypted.kdfParameters || DEFAULT_KDF_CONFIGS.pbkdf2.parameters,
    version: encrypted.kdfVersion || '1.0'
  };
  
  // Derive key using appropriate KDF
  const derivedKey = await deriveKey(
    masterKey,
    Buffer.from(encrypted.salt, 'hex'),
    config
  );
  
  // Decrypt with AES-256-GCM (unchanged)
  const decipher = crypto.createDecipheriv(
    'aes-256-gcm',
    derivedKey,
    Buffer.from(encrypted.iv, 'hex')
  );
  
  decipher.setAuthTag(Buffer.from(encrypted.authTag, 'hex'));
  
  let decrypted = decipher.update(encrypted.encryptedValue, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return JSON.parse(decrypted);
}
```

#### 3. Re-encryption on Rotation

```typescript
export async function rotateCredential(
  credentialId: string,
  newValue: any,
  options?: {
    upgradeKDF?: boolean;  // NEW: Upgrade to Argon2id during rotation
  }
): Promise<void> {
  const existing = getCredentialMetadata(credentialId);
  
  // Determine KDF for new encryption
  let kdfType: KDFType;
  if (options?.upgradeKDF) {
    kdfType = 'argon2id';
  } else {
    // Keep existing KDF type
    kdfType = existing.kdfType || 'pbkdf2';
  }
  
  // Encrypt with chosen KDF
  const encrypted = await encryptCredential(newValue, kdfType);
  
  // Update in database
  updateCredentialValue(credentialId, encrypted);
  
  // Log upgrade if applicable
  if (options?.upgradeKDF && existing.kdfType === 'pbkdf2') {
    logAuditEntry({
      credentialId,
      action: 'kdf_upgrade',
      details: { from: 'pbkdf2', to: 'argon2id' }
    });
  }
}
```

### Performance Impact

| Operation | PBKDF2 (100k) | Argon2id (64MB) | Change |
|-----------|---------------|-----------------|--------|
| Encrypt | 4.2ms | 15-20ms | +~15ms |
| Decrypt | 3.8ms | 15-20ms | +~15ms |
| Memory | ~1MB | ~64MB | +63MB |

**Trade-off Analysis:**
- âœ… **Security:** 10-100x more resistant to GPU attacks
- âš ï¸ **Speed:** 4-5x slower
- âš ï¸ **Memory:** 64x more memory
- âœ… **Mitigation:** Credential caching makes this acceptable

---

## Feature 2: Credential Caching

### Problem Statement

Current performance (v2.0):
- `retrieveCredential()`: ~6ms
- 80% of time spent in PBKDF2/Argon2id
- For high-frequency credentials (e.g., Stripe API key used 100x/sec), this adds significant latency

### Solution: In-Memory LRU Cache with Sliding TTL

### Technical Design

#### Cache Interface

```typescript
/**
 * Cached credential entry
 */
interface CachedCredential {
  value: any;
  credentialId: string;
  entityId: string;
  entityType: 'skill' | 'tool';
  cachedAt: number;
  lastAccess: number;
  accessCount: number;
  version: string;  // For invalidation on rotation
}

/**
 * Cache configuration
 */
export interface CredentialCacheConfig {
  enabled: boolean;
  maxSize: number;          // Max entries (LRU eviction)
  ttl: number;              // TTL in milliseconds
  slidingWindow: boolean;   // Renew TTL on access
  perEntityCache: boolean;  // Separate cache per entity
}

/**
 * Default cache config
 */
export const DEFAULT_CACHE_CONFIG: CredentialCacheConfig = {
  enabled: true,
  maxSize: 1000,
  ttl: 60000,              // 60 seconds
  slidingWindow: true,
  perEntityCache: true
};
```

#### Cache Implementation

```typescript
import { LRUCache } from 'lru-cache';

export class CredentialCache {
  private cache: LRUCache<string, CachedCredential>;
  private config: CredentialCacheConfig;
  private stats: CacheStats;
  
  constructor(config: CredentialCacheConfig) {
    this.config = config;
    this.cache = new LRUCache<string, CachedCredential>({
      max: config.maxSize,
      ttl: config.ttl,
      updateAgeOnGet: config.slidingWindow
    });
    
    this.stats = {
      hits: 0,
      misses: 0,
      evictions: 0,
      invalidations: 0
    };
  }
  
  /**
   * Get credential from cache
   */
  get(
    credentialId: string,
    entityId: string,
    entityType: 'skill' | 'tool'
  ): any | null {
    if (!this.config.enabled) return null;
    
    const key = this.generateKey(credentialId, entityId, entityType);
    const cached = this.cache.get(key);
    
    if (cached) {
      this.stats.hits++;
      cached.lastAccess = Date.now();
      cached.accessCount++;
      return cached.value;
    }
    
    this.stats.misses++;
    return null;
  }
  
  /**
   * Set credential in cache
   */
  set(
    credentialId: string,
    entityId: string,
    entityType: 'skill' | 'tool',
    value: any,
    version: string
  ): void {
    if (!this.config.enabled) return;
    
    const key = this.generateKey(credentialId, entityId, entityType);
    const entry: CachedCredential = {
      value,
      credentialId,
      entityId,
      entityType,
      cachedAt: Date.now(),
      lastAccess: Date.now(),
      accessCount: 0,
      version
    };
    
    this.cache.set(key, entry);
  }
  
  /**
   * Invalidate credential (on rotation/revocation)
   */
  invalidate(credentialId: string): void {
    let count = 0;
    for (const [key, entry] of this.cache.entries()) {
      if (entry.credentialId === credentialId) {
        this.cache.delete(key);
        count++;
      }
    }
    this.stats.invalidations += count;
  }
  
  /**
   * Invalidate by version
   */
  invalidateVersion(credentialId: string, version: string): void {
    for (const [key, entry] of this.cache.entries()) {
      if (entry.credentialId === credentialId && entry.version !== version) {
        this.cache.delete(key);
      }
    }
  }
  
  /**
   * Clear entire cache
   */
  clear(): void {
    this.cache.clear();
  }
  
  /**
   * Get cache statistics
   */
  getStats(): CacheStats {
    return {
      ...this.stats,
      size: this.cache.size,
      hitRate: this.stats.hits / (this.stats.hits + this.stats.misses) || 0
    };
  }
  
  private generateKey(
    credentialId: string,
    entityId: string,
    entityType: 'skill' | 'tool'
  ): string {
    if (this.config.perEntityCache) {
      return `${credentialId}:${entityType}:${entityId}`;
    }
    return credentialId;
  }
}

/**
 * Cache statistics
 */
export interface CacheStats {
  hits: number;
  misses: number;
  evictions: number;
  invalidations: number;
  size?: number;
  hitRate?: number;
}
```

#### Integration with retrieveCredential

```typescript
// Global cache instance
const credentialCache = new CredentialCache(DEFAULT_CACHE_CONFIG);

export function retrieveCredential(
  credentialId: string,
  entityId: string,
  entityType: 'skill' | 'tool',
  context?: ExecutionContext
): DecryptedCredential {
  // Try cache first
  const cached = credentialCache.get(credentialId, entityId, entityType);
  if (cached) {
    // Still log audit (cache hit)
    logAuditEntry({
      credentialId,
      entityId,
      entityType,
      action: 'retrieve',
      success: true,
      cached: true,
      ...context
    });
    
    return {
      id: credentialId,
      name: '<from-cache>',
      type: '<from-cache>',
      service: '<from-cache>',
      value: cached,
      environment: '<from-cache>'
    };
  }
  
  // Cache miss - full retrieval
  assertAccess(credentialId, entityId, entityType, 'read');
  
  const metadata = getCredentialMetadata(credentialId);
  if (metadata.status !== 'active') {
    throw new AccessDeniedError('Credential is revoked');
  }
  
  const decrypted = decryptCredential(metadata.encryptedValue, getMasterKey());
  
  // Store in cache
  credentialCache.set(
    credentialId,
    entityId,
    entityType,
    decrypted,
    metadata.version
  );
  
  logAuditEntry({
    credentialId,
    entityId,
    entityType,
    action: 'retrieve',
    success: true,
    cached: false,
    ...context
  });
  
  return {
    id: metadata.id,
    name: metadata.name,
    type: metadata.type,
    service: metadata.service,
    value: decrypted,
    environment: metadata.environment
  };
}
```

#### Auto-Invalidation

```typescript
export function rotateCredential(
  credentialId: string,
  newValue: any
): void {
  // ... existing rotation logic ...
  
  // Invalidate cache
  credentialCache.invalidate(credentialId);
  
  logAuditEntry({
    credentialId,
    action: 'rotate',
    details: { cacheInvalidated: true }
  });
}

export function revokeCredential(
  credentialId: string,
  reason: string
): boolean {
  // ... existing revocation logic ...
  
  // Invalidate cache
  credentialCache.invalidate(credentialId);
  
  logAuditEntry({
    credentialId,
    action: 'revoke',
    reason,
    details: { cacheInvalidated: true }
  });
  
  return true;
}
```

### Configuration via Environment Variables

```bash
# Enable/disable cache
CREDENTIAL_CACHE_ENABLED=true

# Cache size (LRU eviction)
CREDENTIAL_CACHE_MAX_SIZE=1000

# TTL in milliseconds
CREDENTIAL_CACHE_TTL_MS=60000

# Sliding window (renew TTL on access)
CREDENTIAL_CACHE_SLIDING_WINDOW=true

# Per-entity caching
CREDENTIAL_CACHE_PER_ENTITY=true
```

### Expected Performance

| Scenario | v2.0 (no cache) | v2.5 (cached) | Improvement |
|----------|-----------------|---------------|-------------|
| First access | 6ms | 6ms | 0% |
| Subsequent (PBKDF2) | 6ms | 0.5ms | **~12x faster** |
| Subsequent (Argon2id) | 18ms | 0.5ms | **~36x faster** |
| High-frequency (100 req/s) | 600ms total | 50ms total | **12x throughput** |

---

## Feature 3: Audit Chain Verification

### Problem Statement

Current audit log (v2.0):
- Entries are independent
- No cryptographic proof of ordering
- Can't detect:
  - Deleted entries
  - Reordered entries
  - Modified entries (post-insertion)

### Solution: Blockchain-Like Chained Hashing

Each audit entry contains:
- `entry_hash`: H(entry_data)
- `previous_hash`: H(previous_entry)
- `chain_height`: Sequence number

This creates an **immutable, verifiable chain** where:
- Any modification breaks the chain
- Missing entries are detectable
- Ordering is cryptographically enforced

### Technical Design

#### Updated Audit Log Schema

```typescript
export interface AuditLogEntry {
  // Existing fields
  id: string;
  credentialId: string;
  entityId: string;
  entityType: 'skill' | 'tool';
  action: AuditAction;
  success: boolean;
  userId?: string;
  ipAddress?: string;
  timestamp: string;
  errorMessage?: string;
  details?: Record<string, any>;
  
  // NEW: Chain verification fields
  chainHeight: number;        // Sequence number (1, 2, 3, ...)
  entryHash: string;          // H(entry_data)
  previousHash: string;       // H(previous_entry)
}
```

#### Hash Calculation

```typescript
/**
 * Calculate hash of audit entry
 */
function calculateEntryHash(entry: Omit<AuditLogEntry, 'entryHash' | 'previousHash'>): string {
  const data = JSON.stringify({
    id: entry.id,
    credentialId: entry.credentialId,
    entityId: entry.entityId,
    entityType: entry.entityType,
    action: entry.action,
    success: entry.success,
    userId: entry.userId,
    ipAddress: entry.ipAddress,
    timestamp: entry.timestamp,
    chainHeight: entry.chainHeight,
    details: entry.details
  });
  
  return crypto
    .createHash('sha256')
    .update(data)
    .digest('hex');
}

/**
 * Get hash of previous entry
 */
function getPreviousHash(): string {
  const db = getDb();
  const lastEntry = db
    .prepare(`
      SELECT entry_hash, chain_height
      FROM credential_audit_log
      ORDER BY chain_height DESC
      LIMIT 1
    `)
    .get() as { entry_hash: string; chain_height: number } | undefined;
  
  if (!lastEntry) {
    // Genesis entry
    return '0'.repeat(64);
  }
  
  return lastEntry.entry_hash;
}
```

#### Logging with Chain

```typescript
export function logAuditEntry(entry: Omit<AuditLogEntry, 'id' | 'chainHeight' | 'entryHash' | 'previousHash'>): string {
  const db = getDb();
  
  // Get previous hash and height
  const previousHash = getPreviousHash();
  const chainHeight = getNextChainHeight();
  
  // Generate entry ID
  const id = generateAuditId();
  
  // Calculate entry hash
  const fullEntry = {
    ...entry,
    id,
    chainHeight,
    timestamp: entry.timestamp || new Date().toISOString()
  };
  
  const entryHash = calculateEntryHash(fullEntry);
  
  // Insert with chain data
  db.prepare(`
    INSERT INTO credential_audit_log (
      id, credential_id, entity_id, entity_type, action, success,
      user_id, ip_address, timestamp, error_message, details,
      chain_height, entry_hash, previous_hash
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(
    id,
    fullEntry.credentialId,
    fullEntry.entityId,
    fullEntry.entityType,
    fullEntry.action,
    fullEntry.success ? 1 : 0,
    fullEntry.userId || null,
    fullEntry.ipAddress || null,
    fullEntry.timestamp,
    entry.errorMessage || null,
    entry.details ? JSON.stringify(entry.details) : null,
    chainHeight,
    entryHash,
    previousHash
  );
  
  return id;
}
```

#### Chain Verification

```typescript
/**
 * Verify integrity of audit chain
 */
export function verifyAuditChain(options?: {
  fromHeight?: number;
  toHeight?: number;
  credentialId?: string;
}): AuditChainVerificationResult {
  const db = getDb();
  
  let query = `
    SELECT *
    FROM credential_audit_log
    WHERE 1=1
  `;
  
  const params: any[] = [];
  
  if (options?.fromHeight !== undefined) {
    query += ` AND chain_height >= ?`;
    params.push(options.fromHeight);
  }
  
  if (options?.toHeight !== undefined) {
    query += ` AND chain_height <= ?`;
    params.push(options.toHeight);
  }
  
  if (options?.credentialId) {
    query += ` AND credential_id = ?`;
    params.push(options.credentialId);
  }
  
  query += ` ORDER BY chain_height ASC`;
  
  const entries = db.prepare(query).all(...params) as AuditLogEntry[];
  
  const result: AuditChainVerificationResult = {
    valid: true,
    totalEntries: entries.length,
    verifiedEntries: 0,
    brokenLinks: [],
    missingSequences: [],
    tamperedEntries: []
  };
  
  let expectedHeight = entries[0]?.chainHeight || 1;
  let previousHash = entries[0]?.previousHash || '0'.repeat(64);
  
  for (const entry of entries) {
    // Check sequence
    if (entry.chainHeight !== expectedHeight) {
      result.valid = false;
      result.missingSequences.push({
        expected: expectedHeight,
        actual: entry.chainHeight
      });
    }
    
    // Check previous hash link
    if (entry.previousHash !== previousHash) {
      result.valid = false;
      result.brokenLinks.push({
        height: entry.chainHeight,
        expectedPreviousHash: previousHash,
        actualPreviousHash: entry.previousHash
      });
    }
    
    // Recalculate entry hash
    const calculatedHash = calculateEntryHash(entry);
    if (calculatedHash !== entry.entryHash) {
      result.valid = false;
      result.tamperedEntries.push({
        height: entry.chainHeight,
        id: entry.id,
        expectedHash: calculatedHash,
        actualHash: entry.entryHash
      });
    }
    
    result.verifiedEntries++;
    previousHash = entry.entryHash;
    expectedHeight++;
  }
  
  return result;
}

/**
 * Verification result
 */
export interface AuditChainVerificationResult {
  valid: boolean;
  totalEntries: number;
  verifiedEntries: number;
  brokenLinks: Array<{
    height: number;
    expectedPreviousHash: string;
    actualPreviousHash: string;
  }>;
  missingSequences: Array<{
    expected: number;
    actual: number;
  }>;
  tamperedEntries: Array<{
    height: number;
    id: string;
    expectedHash: string;
    actualHash: string;
  }>;
}
```

#### Export Chain for External Verification

```typescript
/**
 * Export audit chain for external verification
 */
export function exportAuditChain(options?: {
  credentialId?: string;
  format?: 'json' | 'csv';
}): string {
  const db = getDb();
  
  let query = `SELECT * FROM credential_audit_log`;
  const params: any[] = [];
  
  if (options?.credentialId) {
    query += ` WHERE credential_id = ?`;
    params.push(options?.credentialId);
  }
  
  query += ` ORDER BY chain_height ASC`;
  
  const entries = db.prepare(query).all(...params);
  
  if (options?.format === 'csv') {
    return convertToCSV(entries);
  }
  
  return JSON.stringify(entries, null, 2);
}
```

### Performance Impact

| Operation | v2.0 | v2.5 | Overhead |
|-----------|------|------|----------|
| Log audit entry | 0.5ms | 1.2ms | +0.7ms |
| Verify chain (1000 entries) | N/A | ~50ms | N/A |
| Export chain (1000 entries) | N/A | ~100ms | N/A |

**Analysis:**
- Minimal overhead on logging (~0.7ms)
- Verification is offline operation (doesn't impact runtime)
- Provides **forensic-grade** tamper detection

---

## Feature 4: Just-in-Time Access

### Problem Statement

Current access model (v2.0):
- Policies are **standing** (permanent until revoked)
- Once granted, access persists indefinitely
- Violates principle of **least privilege over time**
- Risk: Compromised skill has persistent access

### Solution: Temporal Elevation with Risk Scoring

**Zero-Standing-Privilege Model:**
- Default: No permanent access
- Request access when needed
- Access granted for limited time (e.g., 10 minutes)
- Risk scoring determines approval
- Auto-revoke after expiration

### Technical Design

#### JIT Access Request

```typescript
/**
 * Just-in-Time access request
 */
export interface JITAccessRequest {
  credentialId: string;
  entityId: string;
  entityType: 'skill' | 'tool';
  requestedBy: string;
  reason: string;
  duration: number;            // Duration in seconds
  priority: 'low' | 'normal' | 'high' | 'emergency';
  
  // Optional: For enhanced security
  mfaToken?: string;           // MFA verification
  approver?: string;           // For 2-person rule
  ipAddress?: string;
  userAgent?: string;
}

/**
 * JIT access grant
 */
export interface JITAccessGrant {
  id: string;
  requestId: string;
  credentialId: string;
  entityId: string;
  entityType: 'skill' | 'tool';
  grantedAt: string;
  expiresAt: string;
  revokedAt?: string;
  status: 'active' | 'expired' | 'revoked';
  riskScore: number;           // 0-100
  requiresMFA: boolean;
  requiresApproval: boolean;
  approvedBy?: string;
}
```

#### Risk Scoring

```typescript
/**
 * Calculate risk score for JIT access request
 */
function calculateRiskScore(request: JITAccessRequest): number {
  let score = 0;
  
  // Factor 1: Duration (longer = higher risk)
  if (request.duration > 3600) score += 30;      // > 1 hour
  else if (request.duration > 600) score += 20;   // > 10 min
  else score += 10;
  
  // Factor 2: Priority (emergency = higher risk)
  if (request.priority === 'emergency') score += 25;
  else if (request.priority === 'high') score += 15;
  else score += 5;
  
  // Factor 3: Credential sensitivity
  const cred = getCredentialMetadata(request.credentialId);
  if (cred.environment === 'production') score += 20;
  else if (cred.environment === 'staging') score += 10;
  else score += 5;
  
  // Factor 4: Entity history
  const failedAttempts = getFailedAccessAttempts({
    entityId: request.entityId,
    limit: 10
  });
  score += Math.min(failedAttempts.length * 5, 20);
  
  // Factor 5: Time of day (off-hours = higher risk)
  const hour = new Date().getHours();
  if (hour < 6 || hour > 22) score += 15;
  
  return Math.min(score, 100);
}
```

#### JIT Access Request Flow

```typescript
/**
 * Request just-in-time access to credential
 */
export async function requestJITAccess(
  request: JITAccessRequest
): Promise<JITAccessGrant> {
  // Calculate risk score
  const riskScore = calculateRiskScore(request);
  
  // Determine requirements based on risk
  const requiresMFA = riskScore > 60;
  const requiresApproval = riskScore > 80;
  
  // Validate MFA if required
  if (requiresMFA && !request.mfaToken) {
    throw new JITAccessError(
      'MFA required for this access level',
      { riskScore, requiresMFA: true }
    );
  }
  
  if (requiresMFA) {
    const mfaValid = await verifyMFA(request.requestedBy, request.mfaToken!);
    if (!mfaValid) {
      throw new JITAccessError('Invalid MFA token');
    }
  }
  
  // Check for approval if required
  if (requiresApproval && !request.approver) {
    throw new JITAccessError(
      'Approval required for this access level',
      { riskScore, requiresApproval: true }
    );
  }
  
  // Create temporary access policy
  const grantId = generateId('jit_grant');
  const expiresAt = new Date(Date.now() + request.duration * 1000).toISOString();
  
  const grant: JITAccessGrant = {
    id: grantId,
    requestId: generateId('jit_request'),
    credentialId: request.credentialId,
    entityId: request.entityId,
    entityType: request.entityType,
    grantedAt: new Date().toISOString(),
    expiresAt,
    status: 'active',
    riskScore,
    requiresMFA,
    requiresApproval,
    approvedBy: request.approver
  };
  
  // Store in database
  const db = getDb();
  db.prepare(`
    INSERT INTO jit_access_grants (
      id, request_id, credential_id, entity_id, entity_type,
      granted_at, expires_at, status, risk_score,
      requires_mfa, requires_approval, approved_by
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(
    grant.id,
    grant.requestId,
    grant.credentialId,
    grant.entityId,
    grant.entityType,
    grant.grantedAt,
    grant.expiresAt,
    grant.status,
    grant.riskScore,
    grant.requiresMFA ? 1 : 0,
    grant.requiresApproval ? 1 : 0,
    grant.approvedBy || null
  );
  
  // Log audit entry
  logAuditEntry({
    credentialId: request.credentialId,
    entityId: request.entityId,
    entityType: request.entityType,
    action: 'jit_access_granted',
    success: true,
    userId: request.requestedBy,
    ipAddress: request.ipAddress,
    details: {
      duration: request.duration,
      expiresAt,
      riskScore,
      reason: request.reason
    }
  });
  
  return grant;
}
```

#### Integration with Access Control

```typescript
export function hasAccess(
  credentialId: string,
  entityId: string,
  entityType: 'skill' | 'tool',
  requiredLevel: AccessLevel = 'read'
): boolean {
  const db = getDb();
  
  // Check permanent policy (v2.0 behavior)
  const permanentPolicy = db
    .prepare(`
      SELECT * FROM credential_access_policies
      WHERE credential_id = ?
        AND entity_id = ?
        AND entity_type = ?
        AND revoked_at IS NULL
        AND (expires_at IS NULL OR expires_at > datetime('now'))
    `)
    .get(credentialId, entityId, entityType);
  
  if (permanentPolicy && meetsAccessLevel(permanentPolicy.access_level, requiredLevel)) {
    return true;
  }
  
  // Check JIT grant (v2.5 new)
  const jitGrant = db
    .prepare(`
      SELECT * FROM jit_access_grants
      WHERE credential_id = ?
        AND entity_id = ?
        AND entity_type = ?
        AND status = 'active'
        AND expires_at > datetime('now')
        AND revoked_at IS NULL
      ORDER BY granted_at DESC
      LIMIT 1
    `)
    .get(credentialId, entityId, entityType);
  
  return jitGrant !== undefined;
}
```

#### Auto-Expiration Job

```typescript
/**
 * Expire old JIT grants (run periodically)
 */
export function expireJITGrants(): number {
  const db = getDb();
  
  const result = db.prepare(`
    UPDATE jit_access_grants
    SET status = 'expired'
    WHERE status = 'active'
      AND expires_at <= datetime('now')
  `).run();
  
  if (result.changes > 0) {
    logAuditEntry({
      credentialId: '',
      entityId: 'system',
      entityType: 'skill',
      action: 'jit_grants_expired',
      success: true,
      details: { count: result.changes }
    });
  }
  
  return result.changes;
}

// Run every minute
setInterval(expireJITGrants, 60000);
```

### Configuration

```bash
# Enable JIT access feature
JIT_ACCESS_ENABLED=true

# Default max duration (seconds)
JIT_MAX_DURATION_SECONDS=3600

# Risk thresholds
JIT_MFA_THRESHOLD=60
JIT_APPROVAL_THRESHOLD=80
```

### Example Use Case

**Scenario: Emergency production fix**

```typescript
// Developer needs production Stripe key for emergency fix
const grant = await requestJITAccess({
  credentialId: 'stripe_prod',
  entityId: 'payment_debug_skill',
  entityType: 'skill',
  requestedBy: 'alice@company.com',
  reason: 'Emergency: Payment gateway down, need to debug',
  duration: 600,  // 10 minutes
  priority: 'emergency',
  mfaToken: '123456'  // From authenticator app
});

// Alice can now access for 10 minutes
const cred = retrieveCredential('stripe_prod', 'payment_debug_skill', 'skill');

// After 10 minutes, access automatically expires
// No manual revocation needed
```

---

## Database Schema Changes

### New Tables

#### 1. `jit_access_grants`

```sql
CREATE TABLE IF NOT EXISTS jit_access_grants (
  id TEXT PRIMARY KEY,
  request_id TEXT NOT NULL,
  credential_id TEXT NOT NULL,
  entity_id TEXT NOT NULL,
  entity_type TEXT NOT NULL CHECK(entity_type IN ('skill', 'tool')),
  granted_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  revoked_at TEXT,
  status TEXT NOT NULL CHECK(status IN ('active', 'expired', 'revoked')),
  risk_score INTEGER NOT NULL,
  requires_mfa INTEGER NOT NULL DEFAULT 0,
  requires_approval INTEGER NOT NULL DEFAULT 0,
  approved_by TEXT,
  
  FOREIGN KEY (credential_id) REFERENCES credentials(id)
);

CREATE INDEX idx_jit_grants_credential ON jit_access_grants(credential_id);
CREATE INDEX idx_jit_grants_entity ON jit_access_grants(entity_id, entity_type);
CREATE INDEX idx_jit_grants_status ON jit_access_grants(status, expires_at);
```

### Modified Tables

#### 1. `credentials` - Add KDF metadata

```sql
ALTER TABLE credentials ADD COLUMN kdf_type TEXT DEFAULT 'pbkdf2';
ALTER TABLE credentials ADD COLUMN kdf_parameters TEXT;
ALTER TABLE credentials ADD COLUMN kdf_version TEXT DEFAULT '1.0';
ALTER TABLE credentials ADD COLUMN version TEXT DEFAULT '1';
```

#### 2. `credential_audit_log` - Add chain fields

```sql
ALTER TABLE credential_audit_log ADD COLUMN chain_height INTEGER;
ALTER TABLE credential_audit_log ADD COLUMN entry_hash TEXT;
ALTER TABLE credential_audit_log ADD COLUMN previous_hash TEXT;
ALTER TABLE credential_audit_log ADD COLUMN cached INTEGER DEFAULT 0;

CREATE INDEX idx_audit_chain_height ON credential_audit_log(chain_height);
CREATE INDEX idx_audit_entry_hash ON credential_audit_log(entry_hash);
```

### Migration Script

```sql
-- v2.5 Migration Script
BEGIN TRANSACTION;

-- Add KDF fields to credentials
ALTER TABLE credentials ADD COLUMN kdf_type TEXT DEFAULT 'pbkdf2';
ALTER TABLE credentials ADD COLUMN kdf_parameters TEXT;
ALTER TABLE credentials ADD COLUMN kdf_version TEXT DEFAULT '1.0';
ALTER TABLE credentials ADD COLUMN version TEXT DEFAULT '1';

-- Update existing credentials with default PBKDF2 config
UPDATE credentials
SET kdf_parameters = '{"iterations":100000,"hash":"sha256"}'
WHERE kdf_parameters IS NULL;

-- Add chain fields to audit log
ALTER TABLE credential_audit_log ADD COLUMN chain_height INTEGER;
ALTER TABLE credential_audit_log ADD COLUMN entry_hash TEXT;
ALTER TABLE credential_audit_log ADD COLUMN previous_hash TEXT;
ALTER TABLE credential_audit_log ADD COLUMN cached INTEGER DEFAULT 0;

-- Backfill chain heights for existing entries
WITH numbered AS (
  SELECT id, ROW_NUMBER() OVER (ORDER BY timestamp ASC) as height
  FROM credential_audit_log
)
UPDATE credential_audit_log
SET chain_height = (SELECT height FROM numbered WHERE numbered.id = credential_audit_log.id);

-- Backfill entry hashes (will be recalculated on next access)
-- Note: previous_hash will remain NULL for legacy entries

-- Create JIT access grants table
CREATE TABLE IF NOT EXISTS jit_access_grants (
  id TEXT PRIMARY KEY,
  request_id TEXT NOT NULL,
  credential_id TEXT NOT NULL,
  entity_id TEXT NOT NULL,
  entity_type TEXT NOT NULL CHECK(entity_type IN ('skill', 'tool')),
  granted_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  revoked_at TEXT,
  status TEXT NOT NULL CHECK(status IN ('active', 'expired', 'revoked')),
  risk_score INTEGER NOT NULL,
  requires_mfa INTEGER NOT NULL DEFAULT 0,
  requires_approval INTEGER NOT NULL DEFAULT 0,
  approved_by TEXT,
  
  FOREIGN KEY (credential_id) REFERENCES credentials(id)
);

-- Create indexes
CREATE INDEX idx_jit_grants_credential ON jit_access_grants(credential_id);
CREATE INDEX idx_jit_grants_entity ON jit_access_grants(entity_id, entity_type);
CREATE INDEX idx_jit_grants_status ON jit_access_grants(status, expires_at);
CREATE INDEX idx_audit_chain_height ON credential_audit_log(chain_height);
CREATE INDEX idx_audit_entry_hash ON credential_audit_log(entry_hash);

COMMIT;
```

---

## API Changes

### New APIs

```typescript
// 1. Argon2id support
export function encryptCredential(
  value: any,
  kdfType?: KDFType  // NEW parameter
): Promise<EncryptedCredential>;

export function rotateCredential(
  credentialId: string,
  newValue: any,
  options?: {
    upgradeKDF?: boolean;  // NEW: Upgrade to Argon2id
  }
): Promise<void>;

// 2. Cache management
export function getCacheStats(): CacheStats;
export function clearCache(): void;
export function invalidateCache(credentialId: string): void;

// 3. Audit chain verification
export function verifyAuditChain(options?: {
  fromHeight?: number;
  toHeight?: number;
  credentialId?: string;
}): AuditChainVerificationResult;

export function exportAuditChain(options?: {
  credentialId?: string;
  format?: 'json' | 'csv';
}): string;

// 4. JIT access
export function requestJITAccess(
  request: JITAccessRequest
): Promise<JITAccessGrant>;

export function revokeJITAccess(grantId: string): boolean;

export function getActiveJITGrants(options?: {
  credentialId?: string;
  entityId?: string;
}): JITAccessGrant[];

export function expireJITGrants(): number;
```

### Breaking Changes

**None.** All v2.0 APIs remain unchanged.

New features are opt-in:
- Argon2id via parameter
- Caching via env variable
- JIT access via new API
- Audit verification via new API

---

## Migration Path

### Phase 1: Gradual Adoption (Week 1-2)

1. **Deploy v2.5 code** with default settings:
   ```bash
   # Keep PBKDF2 as default
   DEFAULT_KDF_TYPE=pbkdf2
   
   # Enable cache with conservative settings
   CREDENTIAL_CACHE_ENABLED=true
   CREDENTIAL_CACHE_TTL_MS=30000
   
   # JIT access disabled initially
   JIT_ACCESS_ENABLED=false
   ```

2. **Monitor metrics:**
   - Cache hit rate
   - Performance improvements
   - Any errors

3. **Run chain verification:**
   ```typescript
   const result = verifyAuditChain();
   if (!result.valid) {
     // Investigate issues
   }
   ```

### Phase 2: Argon2id Rollout (Week 3-4)

1. **Test in staging:**
   ```bash
   DEFAULT_KDF_TYPE=argon2id
   ```

2. **Rotate critical credentials** (triggers Argon2id encryption):
   ```typescript
   rotateCredential(credId, newValue, { upgradeKDF: true });
   ```

3. **Monitor performance:**
   - Ensure cache is mitigating Argon2id overhead
   - Verify memory usage is acceptable

4. **Set Argon2id as default:**
   ```bash
   DEFAULT_KDF_TYPE=argon2id
   ```

### Phase 3: JIT Access (Week 5-6)

1. **Enable JIT access:**
   ```bash
   JIT_ACCESS_ENABLED=true
   ```

2. **Start with low-risk credentials:**
   - Development environment credentials
   - Non-production services

3. **Gradually expand:**
   - Staging credentials
   - Production non-critical
   - Production critical (with approval workflow)

4. **Deprecate standing policies:**
   - Review all permanent policies
   - Convert high-risk policies to JIT
   - Keep only necessary standing access

---

## Performance Benchmarks (Expected)

### Baseline (v2.0)

| Operation | Time | Memory |
|-----------|------|--------|
| Encrypt (PBKDF2) | 4.2ms | ~1MB |
| Decrypt (PBKDF2) | 3.8ms | ~1MB |
| Store credential | 5.1ms | ~1MB |
| Retrieve credential | 6.2ms | ~1MB |
| Access check | 0.8ms | <1MB |
| Log audit entry | 0.5ms | <1MB |

### v2.5 (Argon2id + Cache)

| Operation | First Access | Cached | Memory |
|-----------|--------------|--------|--------|
| Encrypt (Argon2id) | 18ms | N/A | ~64MB |
| Decrypt (Argon2id) | 16ms | N/A | ~64MB |
| Store credential | 20ms | N/A | ~64MB |
| Retrieve credential | 20ms | **0.5ms** | ~64MB |
| Access check | 0.8ms | 0.8ms | <1MB |
| Log audit entry (chained) | 1.2ms | 1.2ms | <1MB |
| Verify chain (1000 entries) | N/A | ~50ms | ~10MB |
| JIT access request | 5ms | N/A | ~1MB |

### High-Frequency Scenario

**Scenario:** Skill accesses same credential 100 times/second

| Version | Total Time (100 req) | Throughput |
|---------|----------------------|------------|
| v2.0 (PBKDF2) | 620ms | 161 req/s |
| v2.5 (Argon2id, no cache) | 2000ms | 50 req/s |
| v2.5 (Argon2id, cached) | **70ms** | **1429 req/s** |

**Improvement: 8.8x throughput vs v2.0, 28x vs Argon2id uncached**

---

## Security Analysis

### Threat Model (STRIDE)

#### 1. Spoofing
**Threat:** Attacker impersonates entity to get JIT access

**Mitigation:**
- Risk scoring requires high confidence
- MFA for high-risk requests
- Approval workflow for critical credentials

#### 2. Tampering
**Threat:** Attacker modifies audit log to hide activity

**Mitigation:**
- Chained hashing prevents undetected modification
- `verifyAuditChain()` detects tampering
- Regular verification in CI/CD

#### 3. Repudiation
**Threat:** Entity denies accessing credential

**Mitigation:**
- Audit chain is cryptographically signed
- Includes user ID, IP, timestamp
- Exportable for external verification

#### 4. Information Disclosure
**Threat:** Cache exposes decrypted credentials in memory

**Mitigation:**
- Cache is in-process only (not network accessible)
- TTL limits exposure window
- Auto-invalidation on rotation/revocation
- Can be disabled for ultra-high-security

#### 5. Denial of Service
**Threat:** Argon2id's memory cost enables DoS

**Mitigation:**
- Caching reduces Argon2id invocations
- Rate limiting on JIT requests
- Monitoring of cache stats

#### 6. Elevation of Privilege
**Threat:** Attacker abuses JIT access to gain persistent access

**Mitigation:**
- JIT grants auto-expire (no manual revocation needed)
- Cannot be renewed without new request
- High-risk requests require approval

### Compliance Impact

#### SOC 2

**CC6.1 - Access Controls:**
âœ… JIT access enforces least privilege over time  
âœ… Risk scoring provides defense-in-depth  
âœ… MFA for sensitive operations

**CC7.2 - System Monitoring:**
âœ… Chained audit log is tamper-proof  
âœ… Verification provides evidence of integrity  
âœ… Exportable for auditor review

#### GDPR

**Article 32 - Security:**
âœ… Argon2id provides state-of-the-art protection  
âœ… JIT access minimizes exposure window

**Article 33 - Breach Notification:**
âœ… Audit chain shows complete access history  
âœ… Tamper detection reveals potential breaches

---

## Testing Strategy

### Unit Tests (60 new tests)

1. **Argon2id (15 tests)**
   - Encrypt/decrypt with Argon2id
   - Migration from PBKDF2
   - Parameter validation
   - Memory limits

2. **Caching (20 tests)**
   - Get/set/invalidate
   - TTL expiration
   - Sliding window
   - LRU eviction
   - Stats tracking

3. **Audit Chain (15 tests)**
   - Hash calculation
   - Chain verification
   - Tamper detection
   - Missing entries detection
   - Export functionality

4. **JIT Access (10 tests)**
   - Risk scoring
   - Access request flow
   - MFA validation
   - Approval workflow
   - Auto-expiration

### Integration Tests (12 new tests)

1. **Argon2id Migration (3 tests)**
   - PBKDF2 â†’ Argon2id on rotation
   - Backward compatibility
   - Mixed KDF environment

2. **Cache Integration (3 tests)**
   - Cache miss â†’ full decrypt â†’ cache set
   - Cache hit â†’ fast retrieval
   - Invalidation on rotation

3. **Audit Chain Integration (3 tests)**
   - Chain building during normal ops
   - Verification after 1000 entries
   - Export and re-import

4. **JIT Access Integration (3 tests)**
   - Request â†’ grant â†’ access â†’ expire
   - High-risk request â†’ MFA â†’ approval â†’ grant
   - Denial based on risk score

### E2E Tests (6 new tests)

1. **Complete v2.5 Flow**
   - Store credential with Argon2id
   - Request JIT access (low risk)
   - Retrieve (cache miss)
   - Retrieve again (cache hit)
   - Verify audit chain
   - Wait for expiration
   - Verify access denied

2. **High-Risk Scenario**
   - Production credential
   - Emergency JIT request
   - MFA challenge
   - Approval required
   - Time-limited access
   - Automatic expiration

3. **Mixed KDF Environment**
   - Legacy PBKDF2 credentials
   - New Argon2id credentials
   - Gradual migration
   - No breaking changes

### Performance Tests (5 scenarios)

1. **Argon2id Overhead**
   - Measure encrypt/decrypt time
   - Compare to PBKDF2 baseline

2. **Cache Hit Rate**
   - Simulate high-frequency access
   - Measure hit rate over time

3. **Cache Performance**
   - Compare cached vs uncached retrieval
   - Measure throughput improvement

4. **Chain Verification**
   - Verify 1000 entry chain
   - Verify 10,000 entry chain
   - Measure time and memory

5. **JIT Request Latency**
   - Low-risk request (no MFA)
   - High-risk request (with MFA)
   - Emergency request (with approval)

---

## Implementation Plan

See `V2.5_IMPLEMENTATION_PLAN.md` for detailed week-by-week breakdown.

**Summary:**
- **Week 1:** Argon2id support + tests
- **Week 2:** Credential caching + tests
- **Week 3:** Audit chain verification + tests
- **Week 4:** JIT access + tests
- **Week 5:** Integration + E2E + polish
- **Week 6:** Documentation + migration guide + release

---

## Risks & Mitigation

### Risk 1: Argon2id Memory Usage

**Risk:** 64MB per operation may be excessive in constrained environments

**Mitigation:**
- Configurable memory cost (default: 64MB)
- Can be lowered to 32MB or 16MB if needed
- Caching reduces frequency of operations

### Risk 2: Cache Security

**Risk:** Decrypted credentials in memory are vulnerable

**Mitigation:**
- TTL limits exposure window
- Can be disabled entirely
- Process isolation (not network-exposed)
- Consider memory encryption (OS-level)

### Risk 3: Audit Chain Performance

**Risk:** Hash calculation adds overhead to logging

**Mitigation:**
- Overhead is minimal (~0.7ms)
- Logging is already async
- Verification is offline operation

### Risk 4: JIT Complexity

**Risk:** JIT access adds complexity to access flow

**Mitigation:**
- Opt-in feature (can be disabled)
- Clear documentation and examples
- Backward compatible with v2.0 policies

---

## Success Metrics

v2.5 is successful if:

1. **Performance:** â‰¥10x improvement in cached retrieval
2. **Security:** 100% audit chain verification success
3. **Adoption:** â‰¥50% of credentials using Argon2id within 3 months
4. **Quality:** 100% test pass rate
5. **Compatibility:** Zero breaking changes from v2.0

---

## Next Steps

1. **Review this design** with security team
2. **Approve scope** for v2.5
3. **Begin implementation** (Week 1: Argon2id)
4. **Create v2.6 design** (Extended credential types)

---

**Document Version:** 1.0  
**Last Updated:** December 2025  
**Authors:** Mauricio Perera  
**Status:** âœ… Ready for Implementation

